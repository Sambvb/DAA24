
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Problem-Solving Techniques</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Algorithmic Problem-Solving Techniques</h1>

    <h2>1. Problems in Nature</h2>

    <h3>Iteration</h3>
    <ul>
        <li><strong>Compound Interest:</strong> Keeps adding interest over time</li>
        <li><strong>Traffic Lights:</strong> Switches between red, yellow, and green</li>
    </ul>

    <h3>Recursion</h3>
    <ul>
        <li><strong>Directory Size:</strong> Adds up folder sizes, including subfolders</li>
        <li><strong>Fractals:</strong> Patterns repeat in smaller versions</li>
    </ul>

    <h3>Backtracking</h3>
    <ul>
        <li><strong>Sudoku:</strong> Fills in numbers and fixes mistakes</li>
        <li><strong>Maze:</strong> Tries a path, goes back if stuck</li>
    </ul>

    <h3>Divide and Conquer</h3>
    <ul>
        <li><strong>Merging Records:</strong> Breaks data into pieces and puts it together</li>
        <li><strong>Sorting (Merge Sort):</strong> Splits, sorts, and combines data</li>
    </ul>

    <h3>Greedy Algorithm</h3>
    <ul>
        <li><strong>ATM Withdrawal:</strong> Takes the biggest bills first</li>
        <li><strong>Activity Scheduling:</strong> Chooses the task that ends quickest</li>
    </ul>

    <h3>Dynamic Programming</h3>
    <ul>
        <li><strong>Route Planning:</strong> Solves parts of a route to find the best one</li>
        <li><strong>Fibonacci:</strong> Remembers results to avoid doing the same work again</li>
    </ul>

    <h3>Graph Algorithms</h3>
    <ul>
        <li><strong>Dijkstra (Shortest Path):</strong> Finds the quickest route</li>
        <li><strong>Prim's/Kruskal's (MST):</strong> Connects with the least cost</li>
    </ul>

    <h3>Sorting Algorithms</h3>
    <ul>
        <li><strong>Task Sorting:</strong> Organizes tasks to get them done efficiently</li>
        <li><strong>Ticket Sorting:</strong> Sorts tickets by price</li>
    </ul>

    <h3>Searching Algorithms</h3>
    <ul>
        <li><strong>Linear Search:</strong> Finds a file</li>
        <li><strong>Binary Search:</strong> Finds a word in a sorted list</li>
    </ul>

    <h2>2. Space and Time Efficiency</h2>

    <h3>Space Efficiency</h3>
    <p>Extra memory an algorithm uses</p>

    <h3>Time Efficiency</h3>
    <p>Speed at which an algorithm completes its task</p>

    <h3>Orders of Growth</h3>
    <ul>
        <li><strong>O(1):</strong> Time: Array access. Space: Single variable</li>
        <li><strong>O(log n):</strong> Time: Binary search. Space: Recursive stack</li>
        <li><strong>O(n):</strong> Time: Loop through list. Space: Storing list</li>
        <li><strong>O(n log n):</strong> Time: Merge Sort. Space: Auxiliary space</li>
        <li><strong>O(n²):</strong> Time: Bubble Sort. Space: 2D matrix</li>
        <li><strong>O(2^n):</strong> Time: Brute force. Space: Storing subsets</li>
        <li><strong>O(n!):</strong> Time: Generating permutations. Space: Storing permutations</li>
    </ul>

    <h3>Complexity Order</h3>
    <ul>
        <li>Time: <strong>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(2^n) &lt; O(n!)</strong></li>
        <li>Space: <strong>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(2^n) &lt; O(n!)</strong></li>
    </ul>

    <h3>Why It Matters</h3>
    <ul>
        <li><strong>Optimized Performance:</strong> Faster processing</li>
        <li><strong>Efficient Memory Use:</strong> Saves memory</li>
        <li><strong>Scalability:</strong> Handles larger data sets</li>
        <li><strong>Real-World Impact:</strong> Improves system reliability</li>
        <li><strong>Resource Constraints:</strong> Smooth operation on limited devices</li>
    </ul>

    <h2>3. Design Principles</h2>

    <h3>1. Shortest Path Trees</h3>
    <ul>
        <li>Fundamental technique for finding most efficient routes</li>
        <li>Essential for optimization and navigation challenges</li>
        <li>Practical application in real-world systems like GPS routing</li>
    </ul>

    <h3>2. Partitioning</h3>
    <ul>
        <li>Breaks down complex problems into smaller, manageable segments</li>
        <li>Reduces algorithmic complexity</li>
        <li>Enables more efficient problem-solving approaches</li>
        <li>Demonstrated in algorithms like quicksort</li>
    </ul>

    <h3>3. Balancing and Rotations</h3>
    <ul>
        <li>Maintains optimal performance of data structures</li>
        <li>Prevents performance degradation in search and update operations</li>
        <li>Implemented in self-balancing tree structures</li>
        <li>Examples include AVL and Red-Black trees</li>
    </ul>

    <h3>4. Edge Relaxation</h3>
    <ul>
        <li>Allows dynamic updating of path solutions</li>
        <li>Enables real-time adaptation to new information</li>
        <li>Critical mechanism in pathfinding algorithms</li>
        <li>Prominent in algorithms like Dijkstra's shortest path algorithm</li>
    </ul>

    <h3>5. Level Order Traversal</h3>
    <ul>
        <li>Provides systematic, layer-by-layer problem exploration</li>
        <li>Implements breadth-first approach to problem-solving</li>
        <li>Crucial in graph and tree navigation techniques</li>
    </ul>

    <h3>6. Pruning</h3>
    <ul>
        <li>Eliminates unnecessary or invalid solution paths</li>
        <li>Significantly reduces computational complexity</li>
        <li>Improves efficiency by saving computational time and resources</li>
    </ul>

    <h3>7. Brave and Cautious Travel Strategies</h3>
    <ul>
        <li>Offers flexible problem-solving approaches</li>
        <li><strong>Depth-First Search (DFS):</strong> Enables deep, aggressive exploration</li>
        <li><strong>Breadth-First Search (BFS):</strong> Provides methodical, comprehensive level-by-level investigation</li>
    </ul>

    <h2>4. Hierarchical Data Structures</h2>

    <h3>1. Tree</h3>
    <ul>
        <li><strong>Use:</strong> Representing hierarchies (filesystems, organizations)</li>
        <li><strong>Pro:</strong> Simple and intuitive structure</li>
        <li><strong>Con:</strong> Lacks balance; inefficient operations</li>
    </ul>

    <h3>2. Binary Search Tree (BST)</h3>
    <ul>
        <li><strong>Use:</strong> Sorted data storage and retrieval</li>
        <li><strong>Pro:</strong> Efficient (O(log n)) when balanced</li>
        <li><strong>Con:</strong> Degrades to O(n) if unbalanced</li>
    </ul>

    <h3>3. AVL Tree</h3>
    <ul>
        <li><strong>Use:</strong> Maintaining balance for consistent performance</li>
        <li><strong>Pro:</strong> Always balanced; guarantees O(log n) operations</li>
        <li><strong>Con:</strong> Costly rotations during updates</li>
    </ul>

    <h3>4. 2-3 Tree</h3>
    <ul>
        <li><strong>Use:</strong> Ensuring perfect balance with multi-child nodes</li>
        <li><strong>Pro:</strong> Logarithmic time complexity; robust structure</li>
        <li><strong>Con:</strong> Implementation complexity</li>
    </ul>

    <h3>5. Red-Black Tree</h3>
    <ul>
        <li><strong>Use:</strong> Dynamic operations with approximate balancing</li>
        <li><strong>Pro:</strong> Predictable O(log n) with fewer rotations than AVL</li>
        <li><strong>Con:</strong> Slightly slower lookups compared to AVL</li>
    </ul>

    <h3>6. Heap</h3>
    <ul>
        <li><strong>Use:</strong> Priority management and sorting</li>
        <li><strong>Pro:</strong> Quick min/max access; O(log n) insert/extract</li>
        <li><strong>Con:</strong> Inefficient for general-purpose searches</li>
    </ul>

    <h3>7. Trie</h3>
    <ul>
        <li><strong>Use:</strong> Efficient string and prefix searches</li>
        <li><strong>Pro:</strong> Fast O(m) operations; shared prefixes save space</li>
        <li><strong>Con:</strong> High memory usage due to large node structures</li>
    </ul>

    <h2>5. Array Query Algorithms</h2>

    <h3>Why Needed</h3>
    <ul>
        <li>Efficient Data Access: Fast retrieval of data in large arrays</li>
        <li>Optimized Operations: Reduce time complexity in large datasets</li>
        <li>Dynamic Applications: Handle real-time tasks like range sums or counts</li>
        <li>Memory Efficiency: Balance speed and memory (e.g., Sparse Tables)</li>
    </ul>

    <h3>Implications</h3>
    <ul>
        <li>Speed vs. Complexity: Faster queries require more preprocessing</li>
        <li>Adaptability: Some algorithms allow quick updates (e.g., Fenwick Tree)</li>
        <li>Scalability: Efficiently process millions of data points</li>
    </ul>

    <h3>Applications</h3>
    <ul>
        <li>Range Queries: Sum/Min in a range (Segment/Fenwick Tree)</li>
        <li>Dynamic Updates: Real-time changes (Fenwick Tree, Lazy Propagation)</li>
        <li>Prefix Queries: Cumulative sums (Prefix Sum Array)</li>
        <li>Static Queries: Min/Max lookups (Sparse Table)</li>
        <li>Searches: Finding elements (Binary Search)</li>
        <li>Pattern Matching: Subarray searches (KMP, Sliding Window)</li>
    </ul>

    <h3>Core Principles</h3>
    <ul>
        <li>Divide and Conquer: Split arrays for efficiency (e.g., Segment Tree)</li>
        <li>Preprocessing: Build structures for quick queries</li>
        <li>Caching: Reuse computed values (e.g., Sparse Tables)</li>
        <li>Space-Time Tradeoff: Balance memory and speed</li>
        <li>Incremental Updates: Minimize recomputations</li>
    </ul>

    <h2>6. Trees and Graphs</h2>

    <h3>Tree</h3>
    <ul>
        <li><strong>Definition:</strong> A hierarchical structure with one root and nodes connected in a parent-child relationship</li>
        <li><strong>Characteristics:</strong></li>
        <ul>
            <li>Acyclic (no cycles)</li>
            <li>Connected (all nodes are reachable)</li>
            <li>Directed (parent-child direction)</li>
        </ul>
    </ul>

    <h3>Graph</h3>
    <ul>
        <li><strong>Definition:</strong> A collection of nodes (vertices) connected by edges</li>
        <li><strong>Characteristics:</strong></li>
        <ul>
            <li>Can be cyclic (can have cycles)</li>
            <li>Can be disconnected (some nodes may not be reachable)</li>
            <li>Directed or Undirected (edges can have direction or not)</li>
        </ul>
    </ul>

    <h3>Tree Traversals</h3>
    <ul>
        <li>Pre-order: Visit root, then left and right subtrees</li>
        <li>In-order: Visit left, root, then right subtrees</li>
        <li>Post-order: Visit left, right, then root</li>
        <li>Level-order (BFS): Visit nodes level by level</li>
    </ul>

    <h3>Graph Traversals</h3>
    <ul>
        <li>DFS: Explore as far as possible along each branch</li>
        <li>BFS: Explore all neighbors at the current depth first</li>
    </ul>

    <h3>Applications</h3>
    <h4>Tree Applications</h4>
    <ul>
        <li>File systems</li>
        <li>Expression trees</li>
        <li>Database indexing</li>
        <li>Decision trees in ML</li>
    </ul>
    <h4>Graph Applications</h4>
    <ul>
        <li>Social networks</li>
        <li>Routing (shortest path)</li>
        <li>Web crawling</li>
        <li>Recommendation systems</li>
    </ul>

  

    <h2>7. Sorting and Searching Algorithms</h2>

    <h3>Sorting Algorithms</h3>
    <ul>
        <li><strong>Bubble Sort:</strong> Swaps adjacent elements until sorted. Complexity: O(n²). Use: Small datasets</li>
        <li><strong>Insertion Sort:</strong> Builds the sorted list one element at a time. Complexity: O(n²). Use: Nearly sorted datasets</li>
        <li><strong>Merge Sort:</strong> Divides and merges sublists. Complexity: O(n log n). Use: Large-scale data</li>
        <li><strong>Quick Sort:</strong> Partitions around a pivot and sorts. Complexity: O(n log n) (average). Use: General-purpose sorting</li>
        <li><strong>Heap Sort:</strong> Sorts by using a binary heap. Complexity: O(n log n). Use: Accessing max/min values</li>
    </ul>

    <h3>Searching Algorithms</h3>
    <ul>
        <li><strong>Linear Search:</strong> Checks each element. Complexity: O(n). Use: Small or unsorted datasets</li>
        <li><strong>Binary Search:</strong> Divides sorted list in half. Complexity: O(log n). Use: Sorted data</li>
        <li><strong>Hashing:</strong> Uses a hash function for fast lookups. Complexity: O(1) (avg). Use: Databases and caches</li>
        <li><strong>DFS:</strong> Explores deeply along branches. Complexity: O(V + E). Use: AI, network routing</li>
        <li><strong>BFS:</strong> Explores all neighbors at current depth. Complexity: O(V + E). Use: Shortest path, GPS</li>
    </ul>

    <h3>Real-World Applications</h3>
    <ul>
        <li>Databases: Sorting and searching for efficient retrieval</li>
        <li>E-commerce: Sorting products, binary search for items</li>
        <li>Operating Systems: Sorting files and searching processes</li>
        <li>Web Search Engines: Sorting results, web page searches</li>
        <li>Navigation: BFS/Dijkstra for shortest path finding</li>
    </ul>

    <h1>Graph Algorithms and Algorithm Design Techniques</h1>

    <h2>8. Graph Algorithms: Spanning Trees and Shortest Paths</h2>

    <h3>Spanning Trees</h3>
    <p><strong>Definition:</strong> Connects all nodes with the fewest edges, no cycles</p>
    <ul>
        <li><strong>Minimum Spanning Tree (MST):</strong> A spanning tree with the smallest total edge weight</li>
        <li><strong>Key Algorithms:</strong> Kruskal's, Prim's</li>
    </ul>

    <h4>Applications</h4>
    <ul>
        <li><strong>Network Design:</strong> Reduces cost for connecting nodes or laying cables</li>
        <li><strong>Cluster Analysis:</strong> Groups similar data points</li>
        <li><strong>Circuit Design:</strong> Minimizes wiring costs</li>
    </ul>

    <h3>Shortest Path Algorithms</h3>
    <p><strong>Definition:</strong> Finds the most efficient path between nodes</p>
    <ul>
        <li><strong>Key Algorithms:</strong></li>
        <ul>
            <li><strong>Dijkstra's:</strong> Works with non-negative weights</li>
            <li><strong>Bellman-Ford:</strong> Handles negative weights and detects cycles</li>
            <li><strong>A* Algorithm:</strong> Improves Dijkstra's with heuristics</li>
        </ul>
    </ul>

    <h4>Applications</h4>
    <ul>
        <li><strong>Navigation:</strong> Finds the fastest route (e.g., GPS)</li>
        <li><strong>Telecommunication:</strong> Optimizes data routing</li>
        <li><strong>Logistics:</strong> Finds the best delivery routes</li>
    </ul>

    <h2>9. Algorithm Design Techniques</h2>

    <h3>1. Brave and Cautious Travel</h3>
    <ul>
        <li>Combines exploration (DFS for brave) and safety (BFS for cautious)</li>
        <li><strong>Use:</strong> Solving mazes, navigating graphs</li>
    </ul>

    <h3>2. Pruning</h3>
    <ul>
        <li>Cuts unnecessary parts of the solution space to save time</li>
        <li><strong>Use:</strong> Chess algorithms, optimization tasks</li>
    </ul>

    <h3>3. Lazy Propagation</h3>
    <ul>
        <li>Delays updates until needed, saving effort</li>
        <li><strong>Use:</strong> Efficient range queries in data structures</li>
    </ul>

    <h3>4. Level Order Traversal</h3>
    <ul>
        <li>Visits tree nodes level by level (BFS for trees)</li>
        <li><strong>Use:</strong> Organizational hierarchies, shortest paths in trees</li>
    </ul>

    <h3>5. Edge Relaxation</h3>
    <ul>
        <li>Updates shortest paths gradually during graph traversal</li>
        <li><strong>Use:</strong> Navigation, network routing</li>
    </ul>

    <h3>6. Balancing and Rotations</h3>
    <ul>
        <li>Keeps data structures balanced for faster operations</li>
        <li><strong>Use:</strong> AVL and Red-Black Trees</li>
    </ul>

    <h3>7. Partitioning</h3>
    <ul>
        <li>Divides problems/data into smaller parts</li>
        <li><strong>Use:</strong> Quick Sort, clustering</li>
    </ul>

    <h3>8. Shortest Path Trees</h3>
    <ul>
        <li>Represents shortest paths from one node to all others</li>
        <li><strong>Use:</strong> GPS, optimized network designs</li>
    </ul>

</body>
</html>

```
